You are an expert at constructing Boolean logic rules that identify **sufficient conditions** for a target event, using prediction market data.

Your task: Generate **exactly {{num_of_rules}} Boolean rules** that each represent a condition that is **logically sufficient** to guarantee that the event described by "{{overall_index_question}}" will occur.

Target Event: {{overall_index_question}}
Analysis Date: {{date}}

Before generating rules, internally define what would constitute the occurrence of this target event (scope, scale, impact). Use this internal definition consistently when evaluating whether a rule guarantees the event.

---

# TWO-PHASE GENERATION PROCEDURE (MANDATORY)

### **Phase 1 — Internal Candidate Generation (not in the final output)**
Privately brainstorm a large set of possible rules (e.g., 50+), of which at least half of these must combine THREE distinct market IDs.
Ensure these internal candidates cover **multiple causal mechanisms**, **different types of market signals**, and **different structural forms** (AND/OR/NOT).

### **Phase 2 — Selection of Final Rules (shown in output)**
From the internal candidates, select **exactly {{num_of_rules}} rules** that satisfy:

### **1. Logical Guarantee**
Each final rule must individually *force* or *ensure* the target event, based on the meaning of its markets.

### **2. High Semantic Diversity**
The selected rules must be **maximally distinct in meaning**, not just in structure.
You must include rules that differ across:

- Different causal explanations of the target event
- Different clusters of markets
- Different combinations of signals (policy, economic, military, scientific, epidemiological, etc.)

### **3. Avoid Redundancy**
You must remove or merge rules that are:

- trivially equivalent
- simple negations or permutations
- relying on the same mechanism with only cosmetic changes
- overlapping in meaning or predictive basis


### **4. Prioritize High-Information Rules**
Prefer rules that rely on markets with strong direct logical implications for the target event.
Rules that depend on a single variable MUST justify why that variable alone is sufficient.
Multi-variable rules MUST explain the interaction between signals (why this combination guarantees the event).
Rules using 3 variables are considered higher quality and should be preferred when they remain logically sufficient.
Only use 1–2 variable rules when adding a second or third variable would reduce logical soundness.
Single-variable rules should be treated as default-invalid unless the market explicitly references a global, confirmed, human-scale H5N1 outbreak.
If uncertain, combine it with at least one other reinforcing signal using AND or OR.


### **Never output more than {{num_of_rules}} rules.**
If you identify more than {{num_of_rules}}, select the {{num_of_rules}} most diverse + strongest.

---

# CRITICAL STRUCTURE REQUIREMENTS

1. **Variable Names**
   Use ONLY market IDs listed in the Available Markets section.

2. **Rule Structure**
   - Use 1–3 distinct market IDs per rule
   - Maximum nesting depth: 2
   - AND/OR nodes: exactly 2–3 children
   - NOT nodes: exactly 1 child
   - Leaf nodes must be `"variable"` with `"var"` equal to an allowed market ID

3. **Functional Uniqueness**
   All final rules must be meaningfully and logically distinct.
    UNIQUENESS DEFINITION (MANDATORY)

    Two rules are considered DUPLICATES if they share ANY of the following:
    - the same set of market IDs (order does not matter)
    - the same causal mechanism or interpretation
    - the same logical structure with only superficial changes (e.g., AND reordered, trivial NOT)
    - the same sufficient condition phrased differently

    Every rule MUST introduce a new causal pathway or guarantee mechanism not used before.

    Before finalizing output, internally verify that all rules are pairwise unique under this definition.


4. **Logical Sufficiency**
   Each final rule must, if true, logically *guarantee* that the target event will occur.

---

# AVAILABLE MARKETS

Use ONLY these market IDs as variable names:

{% for market_id, market_info in markets.items() %}
**Market ID:** {{market_id}}
**Question:** {{market_info.question}}
**Description:** {{market_info.description[:200]}}...
---
{% endfor %}

---

# OUTPUT FORMAT (STRICT)

Return a single JSON object:

{
  "content": [
    {
      "reasoning": "<string explaining why this rule is sufficient and how it differs from the others>",
      "verbalization": "<plain English version of the rule>",
      "rule": {
        "node_type": "variable|not|and|or",
        "var": "<market_id>",      (only for variable nodes)
        "arguments": [ ... ]       (required for not/and/or)
      }
    }
  ]
}

### STRICT OUTPUT RULES
- Output **exactly {{num_of_rules}}** rules
- No extra keys anywhere
- Max depth = 2
- Max 3 unique market IDs per rule
- Only valid node types
- Only allowed market IDs
- Valid JSON, no text before or after

---

# FINAL INSTRUCTION

Generate **exactly {{num_of_rules}} logically sufficient, structurally valid, semantically diverse rules now.
Do not exceed the required number.

Before returning the final JSON:
- Count the rules.
- Confirm the count equals {{num_of_rules}}.
- Verify every rule is unique under the uniqueness definition.
- If uniqueness or count cannot be satisfied, regenerate internally until both are true.
